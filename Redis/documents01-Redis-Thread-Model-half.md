# Redis Thread Model
- [Redis Thread Model](#redis-thread-model)
  - [Redis 是单线程还是多线程模型](#redis-是单线程还是多线程模型)
  - [Redis 如何保证指令原子性](#redis-如何保证指令原子性)
    - [单命令原子性](#单命令原子性)
    - [Redis 事务](#redis-事务)
    - [Redis Lua脚本](#redis-lua脚本)
    - [Redis 事务失败了怎么办](#redis-事务失败了怎么办)
      - [事务](#事务)
      - [Lua脚本](#lua脚本)
  - [Redis 中的 BigKey 问题](#redis-中的-bigkey-问题)
    - [BigKey问题排查](#bigkey问题排查)
      - [使用BIGKEYS命令](#使用bigkeys命令)
      - [Debug Object](#debug-object)
      - [memory usage](#memory-usage)
      - [redis-rdb-tools](#redis-rdb-tools)
      - [BigKey问题解决思路](#bigkey问题解决思路)
        - [分割大key](#分割大key)
        - [对象压缩](#对象压缩)
        - [直接删除](#直接删除)
  - [Redis 线程模型总结](#redis-线程模型总结)

## Redis 是单线程还是多线程模型
Redis 整体线程模型可以解释为"客户端多线程"、"服务端单线程"。

Redis 对外提供的键值存储服务的主要流程是单线程，也就是网络IO和数据读写是由单个线程来完成的。除此外 Redis 的其他功能，比如持久化、 异步删除、集群数据同步等，是由额外的线程来执行的。这样做的好处是可以 。因此，严格地说 Redis 并不是全面单线程。

由于Redis是基于内存的操作，查找和操作的时间复杂度都是O(1)，因此CPU并不是Redis的瓶颈。 Redis的瓶颈很可能是机器内存或网络带宽的大小。 既然单线程易于实现并且CPU不会成为瓶颈，那采用单线程解决方案是合乎逻辑的了。

## Redis 如何保证指令原子性
### 单命令原子性
Redis 的主线程是单线程执行的，因此单个Redis 命令的执行是原子性的。这意味着在一条命令执行期间，不会有其他命令被执行，保证了该命令的完整性。

### Redis 事务
通过 MULTI 命令开启一个事务，通过 EXEC 命令执行事务。在 EXEC 执行前， Redis 会将所有命令放入一个队列中，保证他们作为一个整体被执行。

在 EXEC 命令执行期间，Redis 不会处理其他客户端的命令请求，从而保证了事务中的所有操作要么全部执行要么全部不执行。

**注意** 事务不保证原子性失败，如果事务中的命令在执行时出错（如对一个非字符串执行 INCR），事务仍然会继续执行，只是会返回错误信息，而不是回滚整个事务。

### Redis Lua脚本
Redis 支持通过 EVAL 命令执行嵌入的Lua 脚本。Redis 使用一个单个的Lua 解释器来运行脚本，并且保证脚本的执行是原子性的，即在脚本运行时，不会有其他命令被执行。

Lua 脚本可以将多个命令封装在一起执行，实现了事务般的原子性，并且可以执行更复杂的逻辑。

**注意** 执行复杂的Lua 脚本可能会增加Redis 节点的执行时间，从而影响并发性能。因此，应避免在脚本中执行太多代码，尤其是不必要的for 循环，以防止阻塞Redis 服务器

### Redis 事务失败了怎么办
#### 事务
Redis 事务不支持回滚（回滚是用户主动放弃执行），因为它旨在保持Redis 的简单性、高性能和高效。

事务只会在执行时（而非入列时）出现语法错误或类型错误，此时失败命令之后的命令仍然会执行，而不会回滚整个事务。

因为语法错误和类型操作很容易避免，所以不需要支持回滚。

然而，可以使用 WATCH 命令配合 MULTI/EXEC 来实现乐观锁，当监控的key 被修改时，整个事务将失败并被取消，这相当于一次回滚。

#### Lua脚本
Redis Lua 脚本 不支持失败回滚机制。当Lua 脚本在执行过程中遇到错误时，它会停止执行，并且已经成功执行的部分操作也不会被撤销。若要实现失败回滚的效果，需要客户端在脚本中进行自定义的错误处理和回滚逻辑，例如使用 pcall 或 xpcall 捕获错误，然后根据错误信息执行相应的回滚操作。

- 为什么不支持回滚？
  - 性能与简洁性
    - Redis 的设计初衷是追求快速高效，添加事务回滚机制会增加复杂性并影响性能。
  - 原子性保证
    - Lua 脚本本身是原子的，它在执行期间不会被其他命令中断，但一旦出错，就只会停止，不会撤销已执行的操作。

## Redis 中的 BigKey 问题
在Redis中，每个key都有一个对应的value，如果某个key的value过大，就会导致Redis的性能下降或者崩溃，因为Redis需要将大key全部加载到内存中，这会占用大量的内存空间，降低Redis的响应速度，这个问题被称为Big Key问题。

一般而言，下面这两种情况被称为大 key：
- String 类型的 key 对应的value超过 10 MB。
- list、set、hash、zset等集合类型，集合元素个数超过 5000个。

在Redis中，大key通常是由以下几种原因导致的：
- 对象序列化后的大小过大
- 存储大量数据的容器，如set、list等
- 大型数据结构，如bitmap、hyperloglog等

### BigKey问题排查
#### 使用BIGKEYS命令
Redis自带的 BIGKEYS 命令可以查询当前Redis中所有key的信息，对整个数据库中的键值对大小情况进行统计分析，比如说，统计每种数据类型的键值对个数以及平均大小。此外，这个命令执行后，会输出每种数据类型中最大的 bigkey 的信息，对于 String 类型来说，会输出最大 bigkey 的字节长度，对于集合类型来说，会输出最大 bigkey 的元素个数

BIGKEYS命令会扫描整个数据库，这个命令本身会阻塞Redis，找出所有的大键，并将其以一个列表的形式返回给客户端。

需要注意的是，由于BIGKEYS命令需要扫描整个数据库，所以它可能会对Redis实例造成一定的负担。在执行这个命令之前，请确保您的Redis实例有足够的资源来处理它，建议在从节点执行。

#### Debug Object
如果我们找到了Big Key，就需要对其进行进一步的分析。我们可以使用命令debug object key查看某个key的详细信息，包括该key的value大小等。这时候你就可以窥探Redis的内部，看看到底是哪个key太大了。

Debug Object 命令是一个调试命令，当 key 存在时，返回有关信息。 当 key 不存在时，返回一个错误。

#### memory usage
在Redis4.0之前，只能通过DEBUG OBJECT命令估算key的内存使用(字段serializedlength)，但DEBUG OBJECT命令是有误差的。

4.0版本及以上，我们可以使用memory usag命令。

memory usage命令使用非常简单，直接按memory usage key名字；如果当前key存在，则返回key的value实际使用内存估算值；如果key不存在，则返回nil。

对于除String类型之外的类型，memory usage命令采用抽样的方式，默认抽样5个元素，所以计算是近似值，我们也可以指定抽样的个数。

#### redis-rdb-tools
redis-rdb-tools 是一个 python 的解析 rdb 文件的工具，在分析内存的时候，我们主要用它生成内存快照。可以把 rdb 快照文件生成 CSV 或 JSON 文件，也可以导入到 MySQL 生成报表来分析。

#### BigKey问题解决思路
当发现存在大key问题时，我们需要及时采取措施来解决这个问题。下面列出几种可行的解决思路：

##### 分割大key
将Big Key拆分成多个小的key。这个方法比较简单，但是需要修改应用程序的代码。就像是把一个大蛋糕切成小蛋糕一样，有点费力，但是可以解决问题。

或者尝试将Big Key转换成Redis的数据结构。例如，将Big Key转换成Hash，List或者Set等数据结构。

##### 对象压缩
如果大key的大小主要是由于对象序列化后的体积过大，我们可以考虑使用压缩算法来减小对象的大小。Redis自身支持多种压缩算法，例如LZF、Snappy等。

##### 直接删除
如果你使用的是Redis 4.0+的版本，可以直接使用 unlink命令去异步删除。4.0以下的版本 可以考虑使用 scan ,分批次删除。

无论采用哪种方法，都需要注意以下几点：
1. 避免使用过大的value。如果需要存储大量的数据，可以将其拆分成多个小的value。就像是吃饭一样，一口一口的吃，不要贪多嚼不烂。
2. 避免使用不必要的数据结构。例如，如果只需要存储一个字符串，就不要使用Hash或者List等数据结构。
3. 定期清理过期的key。如果Redis中存在大量的过期key，就会导致Redis的性能下降。就像是家里的垃圾，需要定期清理。
4. 对象压缩


## Redis 线程模型总结
- Redis线程模型整体是多线程的，只是后台执行指令的核心线程是单线程的。
- 整个线程模型可以理解为单线程为主。
- 基于这种单线程为主的线程模型，不同客户端的各种指令都需要依次排队执行。


