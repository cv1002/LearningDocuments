# Redis Thread Model
- [Redis Thread Model](#redis-thread-model)
  - [Redis 是单线程还是多线程模型](#redis-是单线程还是多线程模型)
  - [Redis 如何保证指令原子性](#redis-如何保证指令原子性)
    - [单命令原子性](#单命令原子性)
    - [Redis 事务](#redis-事务)
    - [Redis Lua脚本](#redis-lua脚本)
  - [Redis 中的 BigKey 问题](#redis-中的-bigkey-问题)
  - [Redis 线程模型总结](#redis-线程模型总结)

## Redis 是单线程还是多线程模型
Redis 整体线程模型可以解释为"客户端多线程"、"服务端单线程"。

Redis 对外提供的键值存储服务的主要流程是单线程，也就是网络IO和数据读写是由单个线程来完成的。除此外 Redis 的其他功能，比如持久化、 异步删除、集群数据同步等，是由额外的线程来执行的。这样做的好处是可以 。因此，严格地说 Redis 并不是全面单线程。

由于Redis是基于内存的操作，查找和操作的时间复杂度都是O(1)，因此CPU并不是Redis的瓶颈。 Redis的瓶颈很可能是机器内存或网络带宽的大小。 既然单线程易于实现并且CPU不会成为瓶颈，那采用单线程解决方案是合乎逻辑的了。

## Redis 如何保证指令原子性
### 单命令原子性
Redis 的主线程是单线程执行的，因此单个Redis 命令的执行是原子性的。这意味着在一条命令执行期间，不会有其他命令被执行，保证了该命令的完整性。

### Redis 事务
通过 MULTI 命令开启一个事务，通过 EXEC 命令执行事务。在 EXEC 执行前， Redis 会将所有命令放入一个队列中，保证他们作为一个整体被执行。

在 EXEC 命令执行期间，Redis 不会处理其他客户端的命令请求，从而保证了事务中的所有操作要么全部执行要么全部不执行。

**注意** 事务不保证原子性失败，如果事务中的命令在执行时出错（如对一个非字符串执行 INCR），事务仍然会继续执行，只是会返回错误信息，而不是回滚整个事务。

### Redis Lua脚本
Redis 支持通过 EVAL 命令执行嵌入的Lua 脚本。Redis 使用一个单个的Lua 解释器来运行脚本，并且保证脚本的执行是原子性的，即在脚本运行时，不会有其他命令被执行。

Lua 脚本可以将多个命令封装在一起执行，实现了事务般的原子性，并且可以执行更复杂的逻辑。

**注意** 执行复杂的Lua 脚本可能会增加Redis 节点的执行时间，从而影响并发性能。因此，应避免在脚本中执行太多代码，尤其是不必要的for 循环，以防止阻塞Redis 服务器

## Redis 中的 BigKey 问题



## Redis 线程模型总结



