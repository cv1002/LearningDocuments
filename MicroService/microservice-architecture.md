# Microservice Architechture
- [Microservice Architechture](#microservice-architechture)
  - [微服务架构有哪些特征？](#微服务架构有哪些特征)
    - [通过服务实现组件化](#通过服务实现组件化)
    - [按业务能力来划分服务与组织团队](#按业务能力来划分服务与组织团队)
    - [服务即产品](#服务即产品)
    - [智能终端与哑管道](#智能终端与哑管道)
    - [去中心统一化](#去中心统一化)
    - [基础设施自动化](#基础设施自动化)
    - [Design for failure](#design-for-failure)
    - [进化设计](#进化设计)
  - [微服务架构拆分设计](#微服务架构拆分设计)
    - [通用原则](#通用原则)
    - [拆分策略](#拆分策略)
      - [功能维度拆分策略](#功能维度拆分策略)
      - [考虑点](#考虑点)

## 微服务架构有哪些特征？

### 通过服务实现组件化
传统实现组件的方式是通过库（library），传统组件是和应用一起运行在进程中，组件的局部变化意味着整个应用的重新部署。 通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。 另外将服务作为组件可以更明确的定义出组件的边界。

### 按业务能力来划分服务与组织团队
康威定律（Conway’s law）指出：
organizations which design systems … are constrained to produce designs which are copies of the communication structures of these organizations.
任何设计系统的组织，最终产生的设计等同于组织之内、之间的沟通结构。
传统开发方式中，我们将工程师按技能专长分层为前端层、中间层、数据层，前端对应的角色为UI、页面构建师等，中间层对应的角色为服务端业务开发工程师，数据层对应着DBA等角色。 事实上传统应用设计架构的分层结构正反应了不同角色的沟通结构。 而微服务架构的开发模式不同于传统方式，它将应用按业务能力来划分为不同的服务，每个服务都要求在对应业务领域的全栈（从前端到后端）软件实现，从界面到数据存储到外部沟通协作等等。 因此团队的组织是跨功能的，包含实现业务所需的全面的技能。 近年兴起的全栈工程师正是因为架构和开发模式的转变而出现，当然具备全栈的工程师其实很少，但将不同领域的工程师组织为一个全栈的团队就容易的多。

### 服务即产品
传统的应用开发都是基于项目模式的，开发团队根据一堆功能列表开发出一个软件应用并交付给客户后，该软件应用就进入维护模式，由另一个维护团队负责，开发团队的职责结束。 而微服务架构的倡导者提议避免采用这种项目模式，更倾向于让开发团队负责整个产品的全部生命周期。Amazon 对此提出了一个观点：
You buidl it, you run it.
开发团队对软件在生产环境的运行负全部责任，让服务的开发者与服务的使用者（客户）形成每天的交流反馈，来自直接客户端的反馈有助于开发者提升服务的质量。

### 智能终端与哑管道
微服务架构抛弃了 ESB 过度复杂的业务规则编排、消息路由等。 服务作为智能终端，所有的业务智能逻辑在服务内部处理，而服务间的通信尽可能的轻量化，不添加任何额外的业务规则。

### 去中心统一化
传统应用中倾向采用统一的技术平台或产品来解决所有问题。 不是每个问题都是钉子，也不是每个解决方案都是一个锤子。 问题有其具体性，解决方案也应有其针对性。 用最适合的技术方案去解决具体的问题，在大一统的传统应用中其实很难做到，而微服务的架构意味着，你可以针对不同的业务服务特征选择不同的技术平台或产品，有针对性的解决具体的业务问题。

### 基础设施自动化
单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、集成、监控和发布的复杂度都会相应增大。 必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。

### Design for failure
正因为将服务独立在不同的进程中后，引入了额外的失败因素。 任何时刻对服务的调用都可能因为服务方不可用导致失败，这就要求服务的消费方需要优雅的处理此类错误。 这其实是相对传统应用开发方式的一个缺点，不过随着一些开源服务化框架的出现，对业务开发人员而言适当的屏蔽了类似的错误处理，不过开发人员依然需要知道对服务的调用是完全不同于进程内的方法或函数调用的。

### 进化设计
一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约（接口）的兼容性。 对于解耦服务消费方和服务提供方，伯斯塔尔法则（Postel’s law）特别适用：
Be conservative in what you send, be liberal in what you accept.
发送时要保守，接收时要开放。
按照伯斯塔尔法则的思想来设计实现服务调用时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍信息的兼容性。 多余的信息不认识可以忽略，而不应该拒绝或抛出错误。

## 微服务架构拆分设计

### 通用原则
- 闭包原则
  - 当我们需要改变一个微服务的时候，所有的依赖都在这个微服务的组件内，而不需要修改其他的微服务
- 服务自治、接口隔离原则
  - 尽量消除对其他服务的强依赖，这样可以降低沟通成本，提升服务稳定性。
- 持续演进原则
  - 服务拆分的初期，很难确定服务究竟要拆分成什么样
  - 应当逐步划分，持续演进
  - 拆分过程尽量避免影响产品日常迭代
- 服务接口的定义要具备可扩展性
  - 避免环形依赖和双向依赖

### 拆分策略
#### 功能维度拆分策略
大的原则是基于业务复杂度拆分服务：
- 业务复杂度较高，基于领域驱动拆分服务
- 业务复杂度较低，基于基于数据驱动拆分服务
- 还有一种常见拆分场景，基于已有单体架构中逐渐拆分服务

#### 考虑点
主要考虑六点，包括扩展性、复用性、高性能、高可用、安全性、异构性

- 扩展性
  - 区分系统中变与不变的部分
  - 不变的部分一般是成熟的、通用的服务功能
  - 易变的部分一般是改动比较多、满足业务迭代扩展性需要的功能
  - 我们可以将不变的部分拆分出来，作为共用的部分，将易变的部分独立出来满足个性扩展
  - 根据二八原则，易变的部分只占20%，剩下的80%是不变的部分
- 复用性
  - 不同的业务/服务中经常出现重复功能
  - 可以将这些重复的功能拆分出来形成独立的服务
- 高性能
  - 将性能要求高或者性能压力大的模块拆分出来，避免压力大的服务影响其他服务
  - 也可以基于读写分离来拆分
  - 数据一致性是基于性能维度拆分需要考虑的点
- 高可用
  - 将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分开来
  - 重点保证核心服务的高可用
- 安全性
  - 将安全性要求高的服务和要求低的服务拆分开来，区别部署，降低成本
- 异构性
  - 对于队开发语言有要求的业务场景，可以用不同语言将功能独立出来实现独立服务
