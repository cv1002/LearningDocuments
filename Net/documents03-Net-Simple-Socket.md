# Socket
- [Socket](#socket)
  - [Send 函数](#send-函数)
  - [Recv 函数](#recv-函数)

## Send 函数
```c
int send( SOCKET s, const char FAR *buf, int len, int flags );  
```

不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。

- 该函数的第一个参数指定发送端套接字描述符；
- 第二个参数指明一个存放应用程序要发送数据的缓冲区；
- 第三个参数指明实际要发送的数据的字节数；
- 第四个参数一般置0。此时 send 为阻塞式发送。指定 MSG_NOSIGNAL，表示连接关闭时不产生 SIGPIPE 信号。指定 MSG_DONTWAIT 表示非阻塞发送。

这里只描述同步Socket的send函数的执行流程。当调用该函数时，

1. send先比较待发送数据的长度len和套接字s的发送缓冲的长度， 如果len大于s的发送缓冲区的长度，该函数返回SOCKET_ERROR；
2. 如果len小于或者等于s的发送缓冲区的长度，那么send先检查协议是否正在发送s的发送缓冲中的数据，如果是就等待协议把数据发送完，如果协议还没有开始发送s的发送缓冲中的数据或者s的发送缓冲中没有数据，那么send就比较s的发送缓冲区的剩余空间和len
3. 如果len大于剩余空间大小，send就一直等待协议把s的发送缓冲中的数据发送完
4. 如果len小于剩余 空间大小，send就仅仅把buf中的数据copy到剩余空间里（注意并不是send把s的发送缓冲中的数据传到连接的另一端的，而是协议传的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里）。

如果send函数copy数据成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果send在等待协议传送数据时网络断开的话，那么send函数也返回SOCKET_ERROR。

要注意send函数把buf中的数据成功copy到s的发送缓冲的剩余空间里后它就返回了，但是此时这些数据并不一定马上被传到连接的另一端。如果协议在后续的传送过程中出现网络错误的话，那么下一个Socket函数就会返回SOCKET_ERROR。（每一个除send外的Socket函数在执 行的最开始总要先等待套接字的发送缓冲中的数据被协议传送完毕才能继续，如果在等待时出现网络错误，那么该Socket函数就返回 SOCKET_ERROR）

**注意：在Unix系统下，如果send在等待协议传送数据时网络断开的话，调用send的进程会接收到一个SIGPIPE信号，进程对该信号的默认处理是进程终止。**

通过测试发现，异步socket的send函数在网络刚刚断开时还能发送返回相应的字节数，同时使用select检测也是可写的，但是过几秒钟之后，再send就会出错了，返回-1。select也不能检测出可写了。

错误码: 
- EACCES
  - (对于通过路径名标识的 UNIX Domain Sockets)目标套接字文件没有写权限，或者路径前缀中的一个目录没有搜索权限。
  - (对于UDP Sockets)尝试将数据发送到网络/广播地址，却像发送到单播地址一样。
- EAGAIN / EWOULDBLOCK
  - 套接字被标记为非阻塞，请求的操作将会阻塞。
  - POSIX.1-2001 允许在这种情况下返回任一错误，并且不要求这些常量具有相同的值，因此可移植的应用程序应该检查这两种可能性。
  - （Internet domain datagram sockets / UDP）由sockfd引用的套接字之前未绑定到地址，在尝试将其绑定到临时端口时，发现临时端口范围内的所有端口号当前都在使用中。
- EALREADY
  - 另一个快速打开正在进行中
- EBADF
- ECONNRESET
  - 连接被对端 reset
- EDESTADDRREQ
  - 套接字不是连接模式，且未设置对端地址。
- EFAULT
  - 指定的参数中包含无效的用户空间地址
- EINTR
  - 在传输任何数据之前发生了信号
- EINVAL
  - 参数不合法
  - 比如 len 必须大于 0，小于 0 则不合法
- EISCONN
  - 连接模式的套接字已经连接，但指定了接收者。
  - （现在要么返回这个错误，要么忽略接收者指定。）
- EMSGSIZE
  - 套接字类型要求消息必须原子性地发送，而要发送的消息大小使得这一点变得不可能。
- ENOBUFS
  - 网络接口的输出队列已满。这通常表明接口已停止发送，但可能是由暂时性拥塞引起的。
  - 在Linux中，通常不会发生这种情况。当设备队列溢出时，数据包会被静默丢弃。
- ENOMEM
  - 网络接口的输出队列已满。这通常表明接口已停止发送，但可能是由暂时性拥塞引起的。
  - 在Linux中，通常不会发生这种情况。当设备队列溢出时，数据包会被静默丢弃。
- ENOTCONN
  - 套接字未连接，且未指定目标。
- ENOTSOCK
  - 文件描述符 sockfd 不指向套接字。
- EOPNOTSUPP
  - flag 参数中的某些位不适合该套接字类型。
- EPIPE
  - 在面向连接的套接字上已关闭本地端。
  - 在这种情况下，如果未设置MSG_NOSIGNAL，进程也将接收到SIGPIPE信号。

## Recv 函数
```c
int recv( SOCKET s, char FAR *buf, int len, int flags);   
```

不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。

- 该函数的第一个参数指定接收端套接字描述符；
- 第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；
- 第三个参数指明buf的长度；
- 第四个参数一般置0。此时 recv 为阻塞式。指定 MSG_NOSIGNAL，表示连接关闭时不产生 SIGPIPE 信号。指定 MSG_DONTWAIT 表示非阻塞，此时如果 recv 将要阻塞，则产生 EAGAIN / EWOULDBLOCK。

这里只描述同步Socket的recv函数的执行流程。当应用程序调用recv函数时，

1. recv先等待s的发送缓冲中的数据被协议传送完毕，如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR，
2. 如果s的发送缓冲中没有数据或者数据被协议成功发送完毕后，recv先检查套接字s的接收缓冲区，如果s接收缓冲区中没有数据或者协议正在接收数据，那么recv就一直等待，直到协议把数据接收完毕。当协议把数据接收完毕，recv函数就把s的接收缓冲中的数据copy到buf中（注意协议接收到的数据可能大于buf的长度，所以 在这种情况下要调用几次recv函数才能把s的接收缓冲中的数据copy完。recv函数仅仅是copy数据，真正的接收数据是协议来完成的），

recv函数返回其实际copy的字节数。如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。

**注意：在Unix系统下，如果recv函数在等待协议接收数据时网络断开了，那么调用recv的进程会接收到一个SIGPIPE信号，进程对该信号的默认处理是进程终止。**

错误码: 
- EAGAIN / EWOULDBLOCK
  - 套接字被标记为非阻塞，接收操作将会阻塞，或者已经设置了接收超时，但在接收到数据之前超时已经过期。
  - POSIX.1 允许在这种情况下返回这两种错误之一，并且不要求这些常量具有相同的值，因此可移植的应用程序应该检查这两种可能性。
- EBADF
  - 参数 sockfd 是一个无效的文件描述符
- ECONNREFUSED
  - 远程主机拒绝允许网络连接（通常是因为它没有运行请求的服务）。
- EFAULT
  - 接收缓冲区指针超出进程的地址空间
- EINTR
  - 接收在可用任何数据之前被信号中断
- EINVAL
  - 参数不合法
  - 比如 len 必须大于 0，小于 0 则不合法
- ENOMEM
  - 无法为 recvmsg() 分配内存
- ENOTCONN
  - 套接字与面向连接的协议相关联，尚未建立连接
- ENOTSOCK
  - 文件描述符 sockfd 不指向套接字