# Lock
- [Lock](#lock)
  - [按操作类型划分：读锁 \& 写锁](#按操作类型划分读锁--写锁)
  - [按锁的粒度划分：全局锁 \& 表锁 \& 行锁 \& 页锁](#按锁的粒度划分全局锁--表锁--行锁--页锁)
  - [按锁的机制划分：乐观锁 \& 悲观锁](#按锁的机制划分乐观锁--悲观锁)
  - [行锁升级表锁](#行锁升级表锁)
    - [无索引](#无索引)
    - [索引失效](#索引失效)
    - [分析排查](#分析排查)
      - [查看innodb\_row\_lock内部变量](#查看innodb_row_lock内部变量)
      - [查看information\_schema系统库](#查看information_schema系统库)
        - [INNODB\_LOCK\_WAITS](#innodb_lock_waits)
        - [INNODB\_TRX](#innodb_trx)
  - [记录锁 \& 间隙锁 \& 临键锁](#记录锁--间隙锁--临键锁)
    - [记录锁（Record Lock）](#记录锁record-lock)
    - [间隙锁（Gap Lock）](#间隙锁gap-lock)
    - [临键锁（Next-Key Lock）](#临键锁next-key-lock)
    - [间隙锁加锁规则](#间隙锁加锁规则)
    - [间隙锁触发条件](#间隙锁触发条件)
  - [对唯一索引锁定锁定一条存在的记录并不会触发间隙锁](#对唯一索引锁定锁定一条存在的记录并不会触发间隙锁)
  - [当搜索条件仅涉及到多列唯一索引的一部分列时，可能会产生间隙锁](#当搜索条件仅涉及到多列唯一索引的一部分列时可能会产生间隙锁)
- [锁优化实践](#锁优化实践)

## 按操作类型划分：读锁 & 写锁
- 读锁
  - 共享锁 / S锁
  - select ... lock in share mode
  - 读锁是共享的，多个事务可以同时读取一个资源，但不允许其他事务修改
  - 串行事务会在执行查询语句时自动加读锁
- 写锁
  - 独占锁 / X锁
  - select ... for update
  - 写锁是排他的，会阻塞其他的写锁和读锁
  - update、insert、delete都会加写锁

## 按锁的粒度划分：全局锁 & 表锁 & 行锁 & 页锁
- 全局锁
  - 对整个数据库上锁
  - 应用场景：做全库的逻辑备份
- 表锁
  - 每次操作锁住整个表
  - 锁粒度大，冲突概率高，并发度低
- 行锁
  - 每次操作锁住一行数据
  - 锁定粒度最小，冲突概率最低，并发度最高
  - InnoDB引擎支持行锁
- 页锁
  - 每次锁定相邻的一组记录
  - 锁定粒度、开销和枷锁时间介于表锁和行锁之间
  - InnoDB不支持页锁

| 存储引擎 | 行锁 | 页锁 | 表锁 |
| -------- | ---- | ---- | ---- |
| MyISAM   |      |      | 支持 |
| BDB      |      | 支持 | 支持 |
| InnoDB   | 支持 |      | 支持 |

## 按锁的机制划分：乐观锁 & 悲观锁
- 乐观锁
  - CAS算法，基于版本和重试实现
  - 假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，使用版本号机制和CAS算法实现。
- 悲观锁
  - 传统的锁
  - 假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。

## 行锁升级表锁
- 无索引或索引失效情况下，行锁升级表锁。
- 原因：
  - InnoDB引擎的3种行锁算法(Record Lock、Gap Lock、Next-key Lock)，都是锁定的索引。
  - 当触发X锁(写锁)的where条件无索引或索引失效时, 查找的方式就会变成全表扫描，也就是扫描所有的聚集索引记录。

### 无索引
如下的SQL，该SQL没有使用到索引列，那就升级为表锁了。
```SQL
update
    users
set
    user_type = 1
where
    country = "阿根廷";
```

### 索引失效
索引失效的情况有很多, 我们本文不分析为什么失效, 也不会列举出所有失效的场景, 因为那不是本节的重点（我会考虑单独安排一篇详细讲解）。 这里直接用explain说话：
- Explain 返回的 key 不是你期望的索引, 而是PRIMARY;
- Explain 返回的 type 是index或all
- 如果同时满足上述两个条件，说明索引失效了

几个常见的索引失效场景：
- 复合索引未遵循最左前缀原则
- like以%开头
- MySQL成本计算分析认为全表扫描成本更低时
如何避免：
- 禁止where条件使用无索引列进行更新/删除
- 尽可能使用聚集索引进行更新/删除
- 确实需要使用非聚集索引 进行更新/删除，需要确认：    
  - 使用explain检查是否会索引失效
  - 避免对 索引列 进行类型转换、函数、运算符等会造成升级的情况
  - 尽可能减少检索条件范围, 范围越大就越可能被MySQL成本计算太高，从而导致索引失效
- 尽可能控制事务大小，减少锁定时间
  - 涉及事务加锁的sql语句尽可能放在事务最后执行
- 推荐使用读已提交(RC)事务隔离级别
  - **这条非常重要**
  - 对于读已提交(RC)事务隔离级别，由于没有间隙锁(Gap Lock)，所以它的加锁规则相当简单，都是针对匹配索引记录加Record Lock，因为不用解决不可重复读和幻读问题，所以也就不存在锁表了。     
  - 对于可重复读(RR)事务隔离级别，因为引入了间隙锁(Gap Lock)，所以情况变的复杂, 而在RC下, 情况变的简单.

### 分析排查
#### 查看innodb_row_lock内部变量
通过如下SQL，查询MySQL内部变量：
```SQL
show status like 'innodb_row_lock%';
```
结果字段说明：
| 字段                          | 说明                                       |
| ----------------------------- | ------------------------------------------ |
| Innodb_row_lock_current_waits | 当前正在等待锁定的数量                     |
| Innodb_row_lock_current_waits | 当前正在等待锁定的数量                     |
| Innodb_row_lock_time          | 等待总时长:从系统启动到现在锁定总时间长度  |
| Innodb_row_lock_time_avg      | 等待平均时长: 每次等待所花平均时间         |
| Innodb_row_lock_time_max      | 从系统启动到现在等待最长的一次所花时间     |
| Innodb_row_lock_waits         | 等待总次数: 系统启动后到现在总共等待的次数 |

#### 查看information_schema系统库
我们可以通过 INFORMATION_SCHEMA系统库提供的查看事务、锁、锁等待的数据表来分析
```SQL
-- 查看事务
select * from INFORMATION_SCHEMA.INNODB_TRX;
-- 查看锁
select * from INFORMATION_SCHEMA.INNODB_LOCKS;
-- 查看锁等待
select * from INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
-- 查看连接情况
select * from INFORMATION_SCHEMA.PROCESSLIST;
```

##### INNODB_LOCK_WAITS
通过 INNODB_LOCK_WAITS 可以找出阻塞的事务id和锁id
```SQL
select * from INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
```
结果字段说明：
| 字段              | 说明         |
| ----------------- | ------------ |
| requesting_trx_id | 请求的事务id |
| requested_lock_id | 请求的锁id   |
| blocking_trx_id   | 阻塞的事务id |
| blocking_lock_id  | 阻塞的锁id   |

##### INNODB_TRX
通过 INNODB_TRX 可以查看事务的状态、阻塞开始时间、阻塞的sql、线程id等等
```SQL
select * from INFORMATION_SCHEMA.INNODB_TRX;
```
结果字段说明：
| 字段                  | 说明                                                                 |
| --------------------- | -------------------------------------------------------------------- |
| trx_id                | 事务id                                                               |
| trx_state             | 事务状态，LOCK WAIT代表发生了锁等待                                  |
| trx_started           | 事务开始时间                                                         |
| trx_requested_lock_id | 请求锁id, 事务当前正在等待锁的标识，可以join关联INNODB_LOCKS.lock_id |
| trx_wait_started      | 事务开始锁等待的时间                                                 |
| trx_weight            | 事务的权重                                                           |
| trx_mysql_thread_id   | 事务线程 ID，可以join关联PROCESSLIST.ID                              |
| trx_query             | 事务正在执行的 SQL 语句                                              |
| trx_operation_state   | 事务当前操作状态                                                     |
| trx_isolation_level   | 当前事务的隔离级别                                                   |


## 记录锁 & 间隙锁 & 临键锁

### 记录锁（Record Lock）
记录锁也被称为行锁，顾名思义，它是针对数据库中的行记录进行的锁定。
比如：
```SQL
select * from users where user_id=1 for update;
```
上面的SQL会在 user_id=1 的行记录上加上记录锁，以阻止其他事务插入，更新，删除这一行。

### 间隙锁（Gap Lock）
- MySQL中的间隙是指索引中两个索引键之间的空间，间隙锁用于防止范围查询期间的幻读，确保查询结果的一致性和并发安全性。
- 间隙锁就是对间隙加锁，用于锁定索引范围之间的间隙，以避免其他事务在这个范围内插入新的数据。间隙锁是排它锁，阻止了其他事务在间隙中插入满足条件的值，间隙锁仅在可重复读隔离级别下才有效。

### 临键锁（Next-Key Lock）
- 临键锁由记录锁和间隙锁组合而成，它在索引范围内的记录上加上记录锁，并在索引范围之间的间隙上加上间隙锁。这样可以避免幻读（Phantom Read）的问题，确保事务的隔离性。
- 切记：**间隙锁的区间是左开右开的，临键锁的区间是左开右闭的。**

### 间隙锁加锁规则
1. 加锁的基本单位是 Next-Key Lock，左开右闭区间。
2. 查找过程中访问到的对象才会加锁。
3. 唯一索引上的范围查询会上锁到不满足条件的第一个值为止。
4. 唯一索引等值查询，并且记录存在，Next-Key Lock 退化为行锁。
5. 索引上的等值查询，会将距离最近的左边界和右边界作为锁定范围，如果索引不是唯一索引还会继续向右匹配，直到遇见第一个不满足条件的值，如果最后一个值不等于查询条件，Next-Key Lock 退化为间隙锁。

### 间隙锁触发条件
在可重复读（Repeatable Read）事务隔离级别下，以下情况会产生间隙锁：
- 使用普通索引锁定：当一个事务使用普通索引进行条件查询时，MySQL会在满足条件的索引范围之间的间隙上生成间隙锁。
- 使用多列唯一索引：如果一个表存在多列组成的唯一索引，并且事务对这些列进行条件查询时，MySQL会在满足条件的索引范围之间的间隙上生成间隙锁。
- 使用唯一索引锁定多行记录：当一个事务使用唯一索引来锁定多行记录时，MySQL会在这些记录之间的间隙上生成间隙锁，以确保其他事务无法在这个范围内插入新的数据。
> - 需要注意的是，上述情况仅在可重复读隔离级别下才会产生间隙锁。
> - 在其他隔离级别下，如读提交（Read Committed）隔离级别，MySQL可能会使用临时的意向锁来避免并发问题，而不是生成真正的间隙锁。
> - 为什么这里强调的是普通索引呢？因为对唯一索引锁定并不会触发间隙锁。
> - **当使用唯一索引锁定一条存在的记录时，会使用记录锁，而不是间隙锁**

## 对唯一索引锁定锁定一条存在的记录并不会触发间隙锁
> 小知识：唯一索引是这样一种索引，它通过确保表中没有两个数据行具有完全相同的键值来帮助维护数据完整性。

假设我们有一个名为students的表，其中有两个字段：id 和 name。id是主键，现在有两个事务同时进行操作：

事务A执行以下语句：
```SQL
SELECT * FROM students WHERE id = 1 FOR UPDATE;
```
事务B执行以下语句：
```SQL
INSERT INTO students (id, name) VALUES (2, 'John');
```
由于事务A使用了唯一索引锁定，它会锁定id为1的记录，不会触发间隙锁。

同时，在事务B中插入id为2的记录也不会受到影响。这是因为唯一索引只会锁定匹配条件的具体记录，而不会锁定不存在的记录（如间隙）。


## 当搜索条件仅涉及到多列唯一索引的一部分列时，可能会产生间隙锁
> 小知识：多列唯一索引能够保证索引键中值的每个组合都是唯一的。 

假设students表，包含三个列：id、name和age。我们在(name, age)上创建了一个唯一索引。

现在有两个事务同时进行操作：

事务A执行以下语句：
```SQL
SELECT * FROM students WHERE name = 'John' FOR UPDATE;
```
事务B执行以下语句：
```SQL
INSERT INTO students (id, name, age) VALUES (2, 'John', 25);
```

在这种情况下，事务A搜索的条件只涉及到了唯一索引的一部分列（name），而没有涉及到完整的索引列（name, age）。

因此，MySQL会对匹配的记录加上行锁，并且还会对与该条件范围相邻的间隙加上间隙锁。

# 锁优化实践
- 尽可能把所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
- 合理设计索引，尽量缩小锁的范围
- 尽可能减少索引条件范围，避免间隙锁
- 尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的SQL尽量放在事务最后执行
- 尽可能用低的事务隔离级别，优化性能





