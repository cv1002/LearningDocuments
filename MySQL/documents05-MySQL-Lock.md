# Lock
- [Lock](#lock)
  - [按操作类型划分：读锁 \& 写锁](#按操作类型划分读锁--写锁)
  - [按锁的粒度划分：全局锁 \& 表锁 \& 行锁 \& 页锁](#按锁的粒度划分全局锁--表锁--行锁--页锁)
  - [按锁的机制划分：乐观锁 \& 悲观锁](#按锁的机制划分乐观锁--悲观锁)
  - [行锁升级表锁](#行锁升级表锁)

## 按操作类型划分：读锁 & 写锁
- 读锁
  - 共享锁 / S锁
  - select ... lock in share mode
  - 读锁是共享的，多个事务可以同时读取一个资源，但不允许其他事务修改
  - 串行事务会在执行查询语句时自动加读锁
- 写锁
  - 独占锁 / X锁
  - select ... for update
  - 写锁是排他的，会阻塞其他的写锁和读锁
  - update、insert、delete都会加写锁

## 按锁的粒度划分：全局锁 & 表锁 & 行锁 & 页锁
- 全局锁
  - 对整个数据库上锁
  - 应用场景：做全库的逻辑备份
- 表锁
  - 每次操作锁住整个表
  - 锁粒度大，冲突概率高，并发度低
- 行锁
  - 每次操作锁住一行数据
  - 锁定粒度最小，冲突概率最低，并发度最高
  - InnoDB引擎支持行锁
- 页锁
  - 每次锁定相邻的一组记录
  - 锁定粒度、开销和枷锁时间介于表锁和行锁之间
  - InnoDB不支持页锁

| 存储引擎 | 行锁 | 页锁 | 表锁 |
| -------- | ---- | ---- | ---- |
| MyISAM   |      |      | 支持 |
| BDB      |      | 支持 | 支持 |
| InnoDB   | 支持 |      | 支持 |

## 按锁的机制划分：乐观锁 & 悲观锁
- 乐观锁
  - CAS算法，基于版本和重试实现
  - 假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，使用版本号机制和CAS算法实现。
- 悲观锁
  - 传统的锁
  - 假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。

## 行锁升级表锁


