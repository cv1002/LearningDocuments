# GC
- [GC](#gc)
  - [Go V1.3之前的标记-清除(mark and sweep)算法](#go-v13之前的标记-清除mark-and-sweep算法)
    - [标记-清除(mark and sweep)的缺点](#标记-清除mark-and-sweep的缺点)
  - [Go V1.5的三色并发标记法](#go-v15的三色并发标记法)
  - [没有STW的三色标记法](#没有stw的三色标记法)
  - [屏障机制](#屏障机制)
    - ["强-弱" 三色不变式](#强-弱-三色不变式)
    - [插入屏障](#插入屏障)
    - [删除屏障](#删除屏障)
  - [Reference](#reference)

## Go V1.3之前的标记-清除(mark and sweep)算法
此算法主要有两个主要的步骤：

1. 标记(Mark phase)
2. 清除(Sweep phase)

操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 STW(stop the world)。也就是说，这段时间程序会卡在哪儿。

### 标记-清除(mark and sweep)的缺点

- STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)。
- 标记需要扫描整个heap
- 清除数据会产生heap碎片

## Go V1.5的三色并发标记法

三色标记法 实际上就是通过三个阶段的标记来确定清楚的对象都有哪些. 我们来看一下具体的过程.

第一步 , 就是只要是新创建的对象,默认的颜色都是标记为"白色".

第二步, 每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入"灰色"集合。

第四步, 重复第三步, 直到灰色中无任何对象.

第五步: 回收所有的白色标记表的对象. 也就是回收垃圾.

以上便是三色并发标记法, 不难看出,我们上面已经清楚的体现三色的特性, 那么又是如何实现并行的呢?

## 没有STW的三色标记法

我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。我们举一个场景.

如果三色标记法, 标记过程不使用STW将会发生什么事情?

可以看出，有两个问题, 在三色标记法中,是不希望被发生的

- 条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下)
- 条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)

当以上两个条件同时满足时, 就会出现对象丢失现象!

当然, 如果上述中的白色对象3, 如果他还有很多下游对象的话, 也会一并都清理掉.

为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是**STW的过程有明显的资源浪费，对所有的用户程序都有很大影响**，如何能在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？

答案就是, 那么我们只要使用一个机制,来破坏上面的两个条件就可以了.

## 屏障机制
我们让GC回收器,满足下面两种情况之一时,可保对象不丢失. 所以引出两种方式.

### "强-弱" 三色不变式
- 强三色不变式
  - 不存在黑色对象引用到白色对象的指针。
- 弱三色不变式
  - 所有被黑色对象引用的白色对象都处于灰色保护状态.

为了遵循上述的两个方式,Golang团队初步得到了如下具体的两种屏障方式"插入屏障", "删除屏障".

### 插入屏障
具体操作: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)

满足: 强三色不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)

### 删除屏障
具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。

满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)

## Reference
https://zhuanlan.zhihu.com/p/334999060
